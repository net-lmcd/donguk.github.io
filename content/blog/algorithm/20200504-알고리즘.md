---
title: 20200504 알고리즘
date: 2020-05-04 23:05:89
category: algorithm
---

### 1. 무지의 먹방 라이브

```
* 효율성 테스트에 부분 점수가 있는 문제입니다.
```

평소 식욕이 왕성한 무지는 자신의 재능을 뽐내고 싶어 졌고 고민 끝에 카카오 TV 라이브로 방송을 하기로 마음먹었다.

<img src="https://user-images.githubusercontent.com/39187116/80860649-05ea7c80-8ca4-11ea-8db1-e0d71e2dd525.png" width="500" height="500"/>

그냥 먹방을 하면 다른 방송과 차별성이 없기 때문에 무지는 아래와 같이 독특한 방식을 생각해냈다.

회전판에 먹어야 할 N 개의 음식이 있다.
각 음식에는 1부터 N 까지 번호가 붙어있으며, 각 음식을 섭취하는데 일정 시간이 소요된다.
무지는 다음과 같은 방법으로 음식을 섭취한다.

- 무지는 1번 음식부터 먹기 시작하며, 회전판은 번호가 증가하는 순서대로 음식을 무지 앞으로 가져다 놓는다.
- 마지막 번호의 음식을 섭취한 후에는 회전판에 의해 다시 1번 음식이 무지 앞으로 온다.
- 무지는 음식 하나를 1초 동안 섭취한 후 남은 음식은 그대로 두고, 다음 음식을 섭취한다.
  - 다음 음식이란, 아직 남은 음식 중 다음으로 섭취해야 할 가장 가까운 번호의 음식을 말한다.
- 회전판이 다음 음식을 무지 앞으로 가져오는데 걸리는 시간은 없다고 가정한다.

무지가 먹방을 시작한 지 K 초 후에 네트워크 장애로 인해 방송이 잠시 중단되었다.
무지는 네트워크 정상화 후 다시 방송을 이어갈 때, 몇 번 음식부터 섭취해야 하는지를 알고자 한다.
각 음식을 모두 먹는데 필요한 시간이 담겨있는 배열 food_times, 네트워크 장애가 발생한 시간 K 초가 매개변수로 주어질 때 몇 번 음식부터 다시 섭취하면 되는지 return 하도록 solution 함수를 완성하라.

##### 제한사항

- food_times 는 각 음식을 모두 먹는데 필요한 시간이 음식의 번호 순서대로 들어있는 배열이다.
- k 는 방송이 중단된 시간을 나타낸다.
- 만약 더 섭취해야 할 음식이 없다면 `-1`을 반환하면 된다.

##### 정확성 테스트 제한 사항

- food_times 의 길이는 `1` 이상 `2,000` 이하이다.
- food_times 의 원소는 `1` 이상 `1,000` 이하의 자연수이다.
- k는 `1` 이상 `2,000,000` 이하의 자연수이다.

##### 효율성 테스트 제한 사항

- food_times 의 길이는 `1` 이상 `200,000` 이하이다.
- food_times 의 원소는 `1` 이상 `100,000,000` 이하의 자연수이다.
- k는 `1` 이상 `2 x 10^13` 이하의 자연수이다.

##### 입출력 예

| food_times | k    | result |
| ---------- | ---- | ------ |
| [3, 1, 2]  | 5    | 1      |

##### 입출력 예 설명

입출력 예 #1

- 0~1초 동안에 1번 음식을 섭취한다. 남은 시간은 [2,1,2] 이다.
- 1~2초 동안 2번 음식을 섭취한다. 남은 시간은 [2,0,2] 이다.
- 2~3초 동안 3번 음식을 섭취한다. 남은 시간은 [2,0,1] 이다.
- 3~4초 동안 1번 음식을 섭취한다. 남은 시간은 [1,0,1] 이다.
- 4~5초 동안 (2번 음식은 다 먹었으므로) 3번 음식을 섭취한다. 남은 시간은 [1,0,0] 이다.
- 5초에서 네트워크 장애가 발생했다. 1번 음식을 섭취해야 할 때 중단되었으므로, 장애 복구 후에 1번 음식부터 다시 먹기 시작하면 된다.

#### Solution

```python
import heapq as hq
def solution(food_times, k):
    if sum(food_times) <= k:
        return -1
    a = []
    for i in range(len(food_times)):
        hq.heappush(a, (food_times[i], i+1))
    
    sum_value = 0
    previous = 0
    length = len(a)
    remain = 0
    while True:
        v, i = a[0]
        if sum_value + ((v-previous)*length) <= k:
            hq.heappop(a)
            sum_value += (v-previous)*length
            length -= 1
            previous += (v-previous)
        else:
            remain = k - sum_value
            break
    
    a.sort(key=lambda x: x[1])
    return a[remain%length][1]
```



<br/>

### 입국심사

n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다.

처음에 모든 심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다.

모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다.

입국심사를 기다리는 사람 수 n, 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times가 매개변수로 주어질 때, 모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요.

##### 제한사항

- 입국심사를 기다리는 사람은 1명 이상 1,000,000,000명 이하입니다.
- 각 심사관이 한 명을 심사하는데 걸리는 시간은 1분 이상 1,000,000,000분 이하입니다.
- 심사관은 1명 이상 100,000명 이하입니다.

##### 입출력 예

| n    | times   | return |
| ---- | ------- | ------ |
| 6    | [7, 10] | 28     |

##### 입출력 예 설명

가장 첫 두 사람은 바로 심사를 받으러 갑니다.

7분이 되었을 때, 첫 번째 심사대가 비고 3번째 사람이 심사를 받습니다.

10분이 되었을 때, 두 번째 심사대가 비고 4번째 사람이 심사를 받습니다.

14분이 되었을 때, 첫 번째 심사대가 비고 5번째 사람이 심사를 받습니다.

20분이 되었을 때, 두 번째 심사대가 비지만 6번째 사람이 그곳에서 심사를 받지 않고 1분을 더 기다린 후에 첫 번째 심사대에서 심사를 받으면 28분에 모든 사람의 심사가 끝납니다.

#### Solution

```javascript
function check(mid, times){
    let tot = 0
    for (const v of times){
        tot += Math.floor(mid/v)
    }
    return tot
}

function solution(n, times) {
    times.sort((a,b) => a-b)
    let s = 1
    let e = times[times.length-1] * n
    let answer = 1
    while (s<=e){
        const mid = Math.floor((s+e) / 2)
        const tot = check(mid, times)
        if (tot >= n){
            e = mid - 1
            answer = mid
        } else {
            s = mid + 1
        }
    }
    return answer
}
```

