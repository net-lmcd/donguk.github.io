---
title: TCP & UDP
date: 2020-06-09 23:06:53
category: cs
---
OSI 7계층의 **전송 계층**은 송신자와 수신자를 연결하는 통신서비스를 제공하는 계층으로, 쉽게 말해 **데이터 전달을 담당**한다. 이때, 데이터를 **보내기 위해** 사용되는 프로토콜(상호 간에 정의한 규칙)이 `TCP`, `UDP`이다.

![image](https://user-images.githubusercontent.com/39187116/84148796-700ff180-aa9a-11ea-950e-42b980449ee3.png)

<div style="width: 100%; text-align: center;">OSI 7계층(네트워크에서 통신이 일어나는 과정을 7단계로 나눔)</div>

## TCP (Transmission Control Protocol)

TCP는 **인터넷상에서 데이터를 메시지의 형태(패킷 단위)로 보내기 위해 IP와 함께 사용하는 프로토콜**

> 패킷?
>
> 인터넷 내에서 데이터를 보내기 위한 라우팅을 효율적으로 하기 위해서 데이터를 **여러개의 조각들로 나누어 전송을 하는데 이 조각을 패킷**이라고 한다.

일반적으로 TCP와 IP를 함께 사용하는데 IP는 데이터의 배달을 처리한다면, TCP는 **패킷을 추적 및 관리**하게 된다.

> 어떻게 패킷을 추적할까?
>
> 패킷에 번호를 부여하여 패킷의 분실 확인과 같은 처리를 한 뒤 목적지에서 재조립 한다. 

### 특징

- **연결형 서비스(Connection-Oriented)**를 지원하는 프로토콜로 2개의 호스트가 통신을 하기 전 연결이 이루어져야 한다. 이때 가상 회선 방식을 사용한다. 

  > 가상 회선 방식?
  >
  > 발신지와 수신지를 연결하여 패킷을 전송하기 위한 논리적 경로를 배정한다는 말이다.

- 목적지와 수신지를 확실히 하여 정확한 전송을 보장하기 위해서 세션을 수립하는데 이때 **3-way handshaking** 과정을 거친다. 그리고 연결을 끊을 때는 4-way handshaking 과정을 거친다.

- **높은 신뢰성**과 **순서대로 전송하는 것**을 보장한다.

> **흐름 제어**를 통해 송신자의 데이터 양을 조절한다.
>
> **혼잡 제어**를 통해 네트워크 상황을 판단하여 송신자의 데이터 양을 조절한다.
>
> **에러 감지**를 통해 잘못 전송되었을 경우 **재전송**한다.

- 하지만 위와 같은 기능때문에 **UDP보다 속도가 느리다.**
- 두 호스트 모두 송신자와 수신자가 될 수 있다.
- **바이트 스트림**을 사용하여 데이터를 연속적인 바이트로 보고, **세그먼트**라는 단위의 패킷으로 쪼개서 보낸다.
- HTTP, FTP, SMTP, TELNET 등에서 사용된다.

즉, **TCP는 연속성보다 신뢰성있는 전송이 중요할 때 사용하는 프로토콜**이다.

### 3-way handshaking

TCP가 호스트 간에 연결을 설정하는 방법은 SYN/ACK 패킷을 통해 이루어진다. SYN 패킷은 동기화(SYNchronize)를 의미하는 패킷이며 ACK 패킷은 확인(ACKnowledgement)을 의미하는 패킷이다.

![image](https://user-images.githubusercontent.com/39187116/84155011-c2eda700-aaa2-11ea-9055-cdc63e156fe4.png)

1. LISTEN : 서버는 클라이언트의 연결요청을 기다리고 있다.
2. SYN_SENT : 클라이언트는 능동적으로 서버에게 연결요청을 하자고 시퀀스 번호를 생성하여 SYN 패킷에 담아 보낸다. (능동 개방)
3. SYN_RECEIVED : SYN 패킷을 받은 서버는 자신만의 번호를 생성하여 자신의 SYN 패킷에 담고 클라이언트가 보낸 SYN패킷의 번호에 1을 더한 값을 ACK 패킷에 담아서 클라이언트에게 전송한다.
4. ESTABLISHED : SYN + ACK 패킷을 받은 클라이언트는 ACK 패킷에 담긴 번호가 자신이 보낸 번호의 + 1 인지 확인하고 맞다면 연결되었다고 판단하고 서버에서 보낸 SYN 패킷의 번호에 1을 더한 값을 ACK 패킷에 담아 전송한다.
5. ESTABLISHED : ACK 패킷에 담긴 번호가 자신이 보낸 SYN 패킷에 담긴 번호의 +1 이라면 연결이 되었다고 판단한다. 이때부터 본격적인 통신을 할 수 있게 된다.

### 4-way handshaking

![image](https://user-images.githubusercontent.com/39187116/84341120-53300700-abdd-11ea-8c15-30ba9d5efafb.png)

1. 클라이언트는 연결을 종료하겠다는 `FIN` 플래그를 서버에 보낸다.
2. `FIN` 플래그를 받은 서버는 알았다는 의미로 `ACK` 패킷을 보낸다.
3. 그리고 데이터를 모두 받을 때 까지 잠시 `TIME_OUT`이 된다. ( 대기한다. )
4. 데이터 전송이 완료되면 서버는 전송이 끝났다는 것을 알리기 위해 `FIN` 플래그를 보낸다.
5. 클라이언트는 이를 받고 확인 메시지로 `ACK`를 보낸다.
6. `ACK` 패킷을 받은 서버는 TCP 소켓을 `close` 한다.
7. 클라이언트는 잉여 데이터가 남아있는 것을 생각해 일정 시간 동안 세션을 유지하고 패킷을 기다리는 과정을 거친다. (`TIME_OUT`)

<br/>

## UDP (User Datagram Protocol )

UDP는 데이터를 데이터그램 단위로 처리하는 프로토콜이다.

> 데이터그램?
>
> 위에서 라우팅을 효율적으로 하기위해 데이터를 여러개의 조각으로 나눠 보낸다고 했고 이 조각들을 패킷이라고 했다. 데이터 그램은 이 패킷 중 **독립적인 관계를 지닌** 패킷을 말한다.

### 특징

- **비연결형**으로 연결을 설정하고 해체하는 과정이 없다. ( 논리적인 경로가 없다.)
- **신뢰성이 없고 전송되는 데이터의 순서를 보장하지 않는다**. ( 흐름제어, 혼잡제어가 없다. )
- 에러감지는 헤더의 체크섬을 이용한 정도밖에 없다.
- 패킷의 단위가 **데이터그램**으로 경계가 분명하여 수신자는 송신자가 보낸 데이터를 그대로 받게된다.
- 서버와 클라이언트는 유니캐스트(1:1), 브로드캐스트(1:N), 멀티캐스트(1:M)가 가능하다. (N은 전체, M은 일부, TCP는 1:1만 가능)
- TCP에 비해서 하는 작업들이 굉장히 적기 때문에 속도가 빠르다.
- DNS, 비디오/오디오 스트리밍 등에 사용된다.

## 결론

![image](https://user-images.githubusercontent.com/39187116/84158860-5032fa80-aaa7-11ea-80ba-43c106bc89a0.png)

## Reference

1. https://github.com/baeharam/Must-Know-About-Frontend/blob/master/Notes/network/tcp-udp.md
2. https://mangkyu.tistory.com/15
3. https://asfirstalways.tistory.com/356
